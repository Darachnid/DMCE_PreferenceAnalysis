---
title: "Analysis"
format: html
editor: visual
---

Find lit on stats for con/divergence

apply Spearman Rank Correlation on the mean value for each participant in the past 5 min as a continuous scale for every point with y being -1 for divergence and 1 for convergence

a gradient shows the value mean on cont scale

create a model that predicts the value that it shows in in the geom_smooth(). and then genererate error bars to use.

Create something that is related to the area in the boxes

-   a rolling area

    -   time \* (max - min)
    -   look at the rate of change for this value

-   Make a model that predicts the rate of change for a parameter given the time and the rate of change of the other parameters.

    -   Y: Convergence (c(10, 5, 2.5) min rolling mean for range) for Group A

    -   X1: Time (continuous)

    -   X2: Convergence level (c(10, 5, 2.5) min rolling mean for range) for Group B

    -   X3: Convergence level (c(10, 5, 2.5) min rolling mean for range) for Group C

    -   X4: Convergence level (c(10, 5, 2.5) min rolling mean for range) for Group D

    -   **Question 1:** Within what portion of the deliberation is divergence or Convergence most likely to occur?

    -   **Question 2:** How does the convergence level for Groups B, C, and D relate to the convergence level of Group A?

    -   **Question 3:** How does the convergence level for Groups B, C, and D relate to the convergence level of Group A?

    -   

## Libraries

```{r}
library(tidyverse)
library(ggthemes)
library(ggpubr)
library(zoo)
```

## Data Prep

```{r}

# Set theme
theme_set(theme_minimal())


# Define Functions
get_min <- function(Time) { # create a function with the name my_function
  hour <- format(strptime(Time, format="%H:%M:%S"), "%H") 
  min <- format(strptime(Time, format="%H:%M:%S"), "%M")
  sec <- format(strptime(Time, format="%H:%M:%S"), "%S") 
  min <- as.numeric(min) + as.numeric(sec) * (1/60) + as.numeric(hour) * 60
  return(min)
}

# Import Data
data <- read_csv(here::here("data/data.csv")) |>
  mutate(Participant = factor(Participant)) |>
  mutate("Min" = get_min(Time),
         Min = round(Min, 2)) |>
  select(-Time) |>
  arrange(Group, Participant, Min) |>
  mutate(diff = last(Min)) |>
  filter(!is.na(Swimming)) |>
  pivot_longer(cols = c(Swimming, Flooding, Biodiversity, `Water Quality`),
               names_to = "ES") |>
  filter(value != 0)

```

## Easy Plot

```{r}
i <- 0
groups <- unique(data$Group)
for(i in i:3){
  i <- i + 1
  group_num <- groups[i]
data |>
  filter(Group == group_num, value != 0) |>
  mutate(Value = value - 1) |>
  ggplot(aes(x = Min, 
           y = Value)) +
  geom_step(size = 1,
            position = "identity",
            aes(color = Participant)) +
  scale_color_colorblind() +
  labs(x = "Minutes", y = "Importance") + 
  scale_x_continuous(breaks = seq(0, 100, 10),
                     minor_breaks = NULL) +
  scale_y_continuous(minor_breaks = NULL) +
  facet_wrap(~ES, nrow = 4)

ggsave(paste0("out/Group", group_num, "_og.png"), width = 400, height = 200, units = "mm", bg = "white")
ggsave(paste0("out/Group", group_num, "_og.pdf"), width = 400, height = 200, units = "mm", bg = "white")
}
```

## Trend Plot

```{r}
i <- 0
groups <- unique(data$Group)
for(i in i:3){
  i <- i + 1
  group_num <- groups[i]
group <- data |>
  filter(Group == group_num, value != 0) 

interpolated <- group |>
  complete(Min = seq(min(Min), max(Min), by = 0.01), 
           Group = group_num,
           Participant = factor(1:6),
           ES = ES) |>
  left_join(group, by = c("ES", "Min", "Group", "Participant")) |>
  select(ES, Min, Group, Participant, value.x) |>
  rename("Value" = value.x) |>
  arrange(Group, Participant, ES, Min) |>
  group_by(Group, Participant, ES) |>
  fill(Value, .direction = "down") |>
  mutate(Value = round(Value)) |>
  ungroup()

joinedT <- interpolated |>
  group_by(Group, ES, Min) |>
  mutate("Value" = Value - 1) |>
  summarise("ES" = ES,
            "Group" = Group,
            "Min" = Min,
            "Max" = max(Value),
            "Minimum" = min(Value),
            "Mean" = mean(Value),
            "sd" = sd(Value)
            ) |>
  left_join(interpolated, by = c("Group", "ES", "Min"))  

ggplot(joinedT, aes(x = Min, 
           y = Value)) +
    geom_ribbon(aes(ymin = Minimum,
                  ymax = Max), alpha = 1) +
  scale_color_colorblind() +
  labs(x = "Minutes", y = "Importance") + 
  scale_x_continuous(breaks = seq(0, 100, 10),
                     minor_breaks = NULL) +
  scale_y_continuous(minor_breaks = NULL) +
  facet_wrap(~ES, nrow = 4)

ggsave(paste0("out/Group", group_num, ".png"), width = 400, height = 200, units = "mm", bg = "white")
ggsave(paste0("out/Group", group_num, ".pdf"), width = 400, height = 200, units = "mm", bg = "white")
}
```

## Rolling rate Plot

```{r}
time_interval <- 1
window <- 10
k <- round(window/time_interval)
i <- 0
groups <- unique(data$Group)
for(i in i:3){
  i <- i + 1
  group_num <- groups[i]
group <- data |>
  filter(Group == group_num, value != 0) 

interpolated <- group |>
  complete(Min = seq(min(Min), max(Min), by = time_interval), 
           Group = group_num,
           Participant = Participant,
           ES = ES) |>
  left_join(group, by = c("ES", "Min", "Group", "Participant")) |>
  select(ES, Min, Group, value.x, Participant) |>
  rename("Value" = value.x) |>
  arrange(Group, ES, Min) |>
  group_by(Group, ES, Min) |>
  fill(Value, .direction = "down") |>
  mutate(Value = round(Value)) |>
  reframe(ES = ES,
          Min = Min,
          Mean = mean(Value))
  summarise("ES" = ES,
            "Min" = Min,
            "Mean" = mean(Value))
  ungroup()

joined <- interpolated |>
  group_by(Group, ES, Min) |>
  summarise("ES" = ES,
            "Group" = Group,
            "Min" = Min,
            "Maximum" = max(Value),
            "Minimum" = min(Value)) |>
  left_join(interpolated, by = c("Group", "ES", "Min")) |>
  ungroup() |>
  select(ES, Min, Maximum, Minimum)

joined <- interpolated |>
  group_by(Group, ES, Min) |>
  summarise("ES" = ES,
            "Group" = Group,
            "Mean" = mean(Value),
            "se" = sd(Value)/sqrt(n())) |>
  left_join(interpolated, by = c("Group", "ES", "Min")) |>
  ungroup() |>
  select(ES, Min, Maximum, Minimum)

bio <- joined |>
  filter(ES == "Biodiversity") |>
  group_by(Min) |>
  summarise("ES" = "Biodiversity",
             "max" = max(Maximum),
            "min" = min(Minimum)
            ) |>
  mutate("range" = max - min,
         rolling_range = rollmean(range, k = 10, fill = NA, align = "right")) 
flood <- joined |>
  filter(ES == "Flooding") |>
  group_by(Min) |>
  summarise("ES" = "Flooding",
           "max" = max(Maximum),
            "min" = min(Minimum)
            )|>
  mutate("range" = max - min,
         rolling_range = rollmean(range, k = 10, fill = NA, align = "right")) 
swim <- joined |>
  filter(ES == "Swimming") |>
  group_by(Min) |>
  summarise("ES" = "Swimming",
             "max" = max(Maximum),
            "min" = min(Minimum)
            ) |>
  mutate("range" = max - min,
         rolling_range = rollmean(range, k = 10, fill = NA, align = "right")) 
water <- joined |>
  filter(ES == "Water Quality") |>
  group_by(Min) |>
  summarise("ES" = "Water Quality",
            "max" = max(Maximum),
            "min" = min(Minimum)
            ) |>
  mutate("range" = max - min,
         rolling_range = rollmean(range, k = 10, fill = NA, align = "right")) 

combined <- rbind(bio, flood, swim, water) |>
  na.omit()
  

ggplot(combined) +
  geom_ribbon(aes(x = Min,
                  ymin = min,
                  ymax = max)) +
  geom_line(aes(x = Min, 
           y = rolling_range,
           color = ES),
           size = 1) +
  scale_color_colorblind() +
  labs(x = "Minutes", y = "Range of Values") + 
  scale_x_continuous(breaks = seq(0, 100, 10),
                     minor_breaks = NULL) +
  scale_y_continuous(minor_breaks = NULL) +
  facet_wrap(~ES, nrow = 4) 

ggsave(paste0("out/Group", group_num, "range.png"), width = 400, height = 200, units = "mm", bg = "white")
ggsave(paste0("out/Group", group_num, "range.pdf"), width = 400, height = 200, units = "mm", bg = "white")
}
```
